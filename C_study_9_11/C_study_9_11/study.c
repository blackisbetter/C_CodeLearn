#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main()
{
	//访问一个结构体成员
	// .      结构体变量.结构体成员
	// ->     结构体指针->结构体成员

	//struct Stu
	//{
	//	char name[20];
	//	int age;
	//	double score;
	//};

	//void set_stu(struct Stu* ps)
	//{
	//	strcpy(ps->name, "zhangsan");//ps->name与 *(ps.name)相同
	//	ps->age = 20;
	//	ps->score = 100.0;
	//}

	//void print_stu(struct Stu ss)
	//{
	//	printf("%s %d %lf\n",ss.name,ss.age,ss.score);
	//}

	//struct Stu s = { 0 };
	//set_stu(&s);
	//print_stu(s);


	//表达式求值
	//表达式求值的顺序一部分是由操作符的优先级和结合性决定的
	//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型


	//隐式类型转换
	//C的整形算数运算总是至少以缺少整型类型的精度来进行的
	//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型
	//这种转换称为整型提升
	//总的来说就是一个表达式中未达到整型大小的需要整型提升


	//例如:
	//char a,b,c;
	//a=b+c;
	//b和c的值先被提升为普通整型，然后再执行加法运算
	//加法运算完成之后，结果将被截断，然后再存储于a中

	//如何进行整型提升呢？？？
	//整型提升是按照变量的数据类型的符号为来提升的

	//负数的整型提升
	//char c1 = -1;
	//变量的c1的二进制位（补码）中只有8个比特位
	//11111111
	//因为char是有符号的char
	//所以整型提升的时候，高位补充符号位，即为1
	//提升之后的结果是：
	//11111111111111111111111111111111


	//正数的整形提升
	//char c2 = 1;
	//变量c2的二进制位（补码）中只有8个比特位
	//00000001
	//因为char是由符号的char
	//所以整型提升的时候，高位补充符号位，即为0
	//提升之后的结果是：
	//00000000000000000000000000000001

	//无符号整型提升，高位补0
	

	//
	//char a = 5;
	//00000000000000000000000000000101
	//00000101 - a

	//char b = 126;
	//00000000000000000000000001111110
	//01111110 - b

	//char c = a + b;
	//00000000000000000000000000000101 -a
	//00000000000000000000000001111110 -b
	//00000000000000000000000010000011 -c
	//10000011 -c
	//11111111111111111111111110000011 -c补码
	//11111111111111111111111110000010
	//10000000000000000000000001111101 -c原码 -125

	//还没达到整型大小就会整型提升
	//无符号的char和short整型提升高位补0

	//注意：整型提升是有一个表达式中未达到整型大小的需要整型提升

	//char c = 1;
	//printf("%u\n",sizeof(c));//不是表达式不需要整型提升
	//printf("%u\n",sizeof(+c));//4   //+c属于表达式，所以需要整型提升
	//printf("%u\n",sizeof(-c));//4   //-c属于表达式，所以需要整型提升
	//因为+c和-c都属于表达式，发生了整型提升，char类型提升成了普通整型
	
	//算数转换
	//如果某个操作数的各个操作数属于不同的类型，那么除了其中一个操作数转换为
	//另一个操作数的类型，否则操作就无法进行。
	
	//long double
	//double
	//float
	//unsigned long int 
	//long int
	//unsigned int 
	//int 

	//上面的算数转换是从下往上算数转换的
	
	//但是算数转换要合理，要不然会有一些潜在的问题
	//float f = 3.14f;
	//int num = f;//隐式转换（算数转换）,但是注意精度丢失。

	//操作符的属性
	//复杂的表达式的求值有三个影响的因素
	//1.操作符的优先级
	//2.操作符的结合性
	//3.是否控制求值顺序

	//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者优先级相同，取决于
	//他们的结合性

	//结合性主要是  N/A无  L-R从左到右  R-L从右到左
	// 
	// 
	// 
	// 操作符    描述          用法示例            结合性     是否控制求值顺序
	//   ()      聚组        （表达式）             N/A            否
	//   ()     函数调用    rexp(rexp,..rexpn)      L-R            否 
	//   []     下标引用    rexp[rexp]              L-R            否
	//    .   访问结构成员  lexp.member_name        L-R             否
	//   ->  访问结构指针成员 rexp->member_n        L-R             否
	//   ++     后缀自增      lexp++               L-R             否
	//   --     后缀自减      lexp--               L-R             否
	//   !      逻辑反        !rexp               R-L(右到左)      否
	//   ~      按位取反      ~rexp               R-L(右到左)      否
	//   +    单目，表示正值   +rexp              R-L(右到左)       否
	//   -    单目，表示负值   -rexp              R-L(右到左)       否
	//   ++     前缀自加       ++lexp             R-L(右到左)      否
	//   --     前缀自减       --lexp             R-L(右到左)      否
	//    *     间接访问        *rexp             R-L(右到左)      否
	//    &      取地址         &lexp             R-L(右到左)      否
	//  sizeof 算长度，单位字节  sizeof(rexp)      R-L(右到左)      否
	//  (类型)   类型转换        (类型)rexp        R-L(右到左)      否
	//   *       乘法          rexp*rexp          L-R             否
	//   /       除法          rexp/rexp          L-R             否
	//   %       整数取余      rexp%rexp          L-R             否
	//   +       加法          rexp+rexp          L-R             否
	//   -       减法          rexp-rexp          L-R             否
	//   <<     左移位         rexp<<rexp         L-R             否
	//   >>     右移位         rexp>>rexp         L-R             否
	//   >       大于          rexp>rexp          L-R             否
	//   >=     大于等于       rexp>=rexp         L-R             否
	//   <       小于          rexp<rexp          L-R             否
	//   <=     小于等于       rexp<=rexp         L-R             否
	//   ==      等于          rexp==rexp         L-R             否
	//   !=     不等于         rexp!=rexp         L-R             否
	//    &      按位与        rexp & rexp        L-R             否
	//    ^     按位异或       rexp ^ rexp        L-R             否
	//    |      按位或        rexp | rexp        L-R             否
	//    &&     逻辑与        rexp && rexp       L-R             是
	//    ||     逻辑或        rexp || rexp       L-R             是
	//    ?:     条件操作符    rexp?rexp:rexp      N/A            是
	//     =      赋值          lexp = lexp        R-L(右到左)    否
	//    +=     以...加        lexp += lexp       R-L(右到左)    否
	//    -=     以...减        lexp -= lexp       R-L(右到左)    否
	//    *=     以...乘        lexp *= lexp       R-L(右到左)    否
	//    /=     以...除        lexp /= lexp       R-L(右到左)    否
	//    %=     以...取模      lexp %= lexp       R-L(右到左)    否
	//   <<=     以...左移      lexp <<= lexp      R-L(右到左)    否
	//   >>=     以...右移      lexp >>= lexp      R-L(右到左)    否
	//   &=      以...与        lexp &= lexp       R-L(右到左)    否
	//   ^=      以...异或      lexp ^= lexp       R-L(右到左)    否
	//   |=      以...或        lexp |= lexp       R-L(右到左)    否
	//   ，        逗号         rexp,rexp,rexp     L-R            是  

	
	//相邻操作符的优先级相同，取决于结合性。
	

	return 0;
}